# Mini‑SQL 7天·3人·渐进式最终方案（G 版）—完整设计文档

> 目标：7 天内交付 **能跑、能演示、可扩展** 的迷你 SQL 系统；覆盖任务书全部刚性评分点（编译器四阶段、页式存储与缓存、五个基础算子、持久化、交互演示），并预留“卷项目”的高级扩展（索引 / 存储过程 / 触发器 / 游标 / 简易优化）。

---

## 0. 摘要（Executive Summary）
- **分工模型（G 版）**：
  - **A：语言前端 + CLI**（Lexer / Parser / Semantic / Planner + CLI 四视图）
  - **B：存储 + 引擎 + 目录**（页式存储 / 缓冲池 / 执行器 / 系统目录 / 最小索引与高级特性）
  - **C：网络 + 驱动 + WinUI3**（TCP 3306 风格协议 / Python 驱动 / 微客户端）
- **渐进策略**：D1 即跑通“建表→插入→查询”最小闭环；随后逐日替换增强，**接口不变**。
- **亮点**：
  - CLI **四视图**（Token/AST/Semantic/Plan）一屏展示评分产物；
  - **页式 + LRU/FIFO** 命中率与替换日志可截图；
  - **双客户端**（CLI + WinUI3）连到 **3306** 协议的服务端；
  - 高级项采取“**有序块索引 → B+ 树平滑升级**”、“过程/触发器最小子集先可用”。

---

## 1. 演进评估：初版 vs 升级版（均为 GPT 早期稿）



### 1.2 我对“升级版（GPT‑5 迭代稿）”的评分与理由
- **评分：9.4/10**
- **优点**：
  - 把评分项逐条映射到**每日里程碑**，每天都能截图；
  - 明确 **SlottedPage / BufferPool / Executor** 的接口骨架；
  - 设定 **“有序块 → B+ 树”** 的兼容升级路线，降低 D5 风险；
  - **PREPARE/FETCH** 游标分页 + WinUI3 导出 CSV，演示友好；
- **不足**：
  - 部分二进制布局与异常结构仍是“口头约定”，实现靠团队补足；
  - B 的工作量偏重（页/缓存/索引/触发器/过程），需要严格取舍优先级。

### 1.3 本文“G 版”的优化点
- **接口先行、实现渐进**：对 **页/缓冲/索引/游标** 的接口做稳定约束，允许先行“简单实现”后替换；
- **演示优先**：将 **CLI 四视图 / LRU 统计 / 3306 连通 / WinUI3 表格** 固化为 D1-D5 的强制物料；
- **工作量平衡**：高级功能采用 **“最小可用”** 策略（AFTER INSERT/DELETE 触发器；无控制流的过程；等值/范围的索引）。

---

## 2. 目标与范围（Scope）
- **必做**：
  1) 编译器四阶段（Token/AST/Semantic/Plan）与错误定位；
  2) 页式存储（4KB SlottedPage）、缓存（LRU/FIFO 可切换）、命中统计与替换日志；
  3) 执行器五算子：CreateTable/Insert/SeqScan/Filter/Project；
  4) 系统目录（sys_tables/sys_columns/sys_indexes）持久化；
  5) CLI 交互 + 3306 风格 TCP 服务 + Python 驱动 + WinUI3 微客户端；
  6) 持久化验证（重启后数据不丢）。
- **加分项（可选、按序）**：
  - 索引 v1（有序块 + 溢出页），v2（B+ 树叶子链，= 与范围）；
  - 触发器（AFTER/BEFORE × INSERT/DELETE 最小集）；
  - 存储过程（BEGIN…END 顺序执行 + 参数替换，无 IF/WHILE）；
  - 游标（PREPARE/FETCH 分页，服务器保存 iterator）。
- **不做 / 只展望**：事务/并发控制、WAL、锁管理、基于代价的全量优化器。

---

## 3. 总体架构（分层与目录）
```
mini-sql/
├─ sql/                      # 前端（A）
│  ├─ lexer.py               # 词法四元式 (type, lexeme, line, col)
│  ├─ parser.py              # 语法：AST（CREATE/INSERT/SELECT/DELETE）
│  ├─ semantic.py            # 语义：表/列/类型/列数检查；错误=[类型,位置,原因]
│  └─ planner.py             # 计划：Create/Insert/SeqScan/Filter/Project (JSON)
│
├─ storage/                  # 存储（B）
│  ├─ page.py                # 4KB 槽式页：页头/槽目录/变长记录
│  ├─ buffer.py              # BufferPool(LRU/FIFO) + 命中统计/替换日志
│  ├─ file_manager.py        # 表与索引文件 (.tbl/.idx) 读写
│  └─ serdes.py              # 行结构编解码（列偏移 + NULL 位图）
│
├─ engine/                   # 引擎（B）
│  ├─ storage_engine.py      # 表=页集合；seq_scan/insert/delete；RID= (pid, sid)
│  ├─ executor.py            # 解释计划树，执行五算子
│  ├─ catalog_mgr.py         # 系统目录：sys_tables/sys_columns/sys_indexes
│  ├─ index_ordered.py       # v1：有序块+二分+溢出页（接口与 B+ 兼容）
│  ├─ index_bpt.py           # v2：B+ 树（叶子链，= 与范围）
│  ├─ proc_mgr.py            # 存储过程最小子集
│  └─ trigger_mgr.py         # 触发器最小子集
│
├─ wire/                     # 网络（C）
│  ├─ protocol.py            # 帧：len(4B LE)+type(1B)+json(utf-8)
│  ├─ server.py              # AUTH/QUERY/PREPARE/FETCH/OK/ERR/RESULT
│  └─ driver_py/minidb.py    # Python 驱动：connect/execute/fetch*
│
├─ cli/minidb_cli.py         # CLI：多语句、四视图、表格/错误显示
├─ client/winui3/            # C# WinUI3：连接/SQL/表格/导出 CSV
└─ tests/                    # 单元/集成/持久性/性能与负样例
```

### 3.1 模块边界（强约束）
- **Planner 输出**：稳定的 **Plan JSON**（详见 §5.1），A 与 B 解耦；
- **StorageEngine 接口**：`create_table/insert_row/seq_scan/delete_where`（详见 §5.2），B 与上层解耦；
- **Wire 协议**：`AUTH/QUERY/PREPARE/FETCH/OK/ERR/RESULT` 帧格式固定（详见 §6）。

---

## 4. 数据与物理设计

### 4.1 SlottedPage（4KB 槽式页）
- **页头**（示意）：
  - magic(2) | page_id(4) | free_off(2) | slot_cnt(2) | slot_dir_off(2)
- **槽目录**：数组项 `(offset:2, length:2, tomb:1)`；
- **数据区**：自后向前生长，写入变长记录；
- **插入**：检查 `free_off` 与槽目录剩余空间 → 写数据 → 新增槽项；
- **删除**：`tomb=1` 逻辑删除；紧凑与页分裂延后实现；
- **序列化**：`to_bytes()/from_bytes()` 完成页头与槽目录打包。

### 4.2 BufferPool（LRU/FIFO + 统计/日志）
- **结构**：`OrderedDict` 维护热点页；容量 `N` 页；
- **统计**：`hits/misses/hit_ratio/evictions/policy`；
- **替换日志**：记录 `time, victim_pid, cause`；
- **策略开关**：`policy = "LRU" | "FIFO"`；
- **刷盘**：脏页在 close/阈值/定时触发。

### 4.3 记录编码（serdes）
- **布局**：NULL 位图 + 列偏移表 + 变长数据；
- **类型支持**：`INT`, `VARCHAR(n)`；
- **RID**：`(page_id, slot_id)`；
- **表文件**：`.tbl`，索引文件 `.idx`。

### 4.4 索引设计（两阶段）
- **v1：有序块 + 溢出页**（等值/范围 → 二分 + 顺扫），**D5 首选**；
- **v2：B+ 树**（叶子链），接口**不变**，替换实现即可；
- **维护**：`INSERT/DELETE` 同步更新；`UPDATE` 如涉及键列可先重插。

---

## 5. 上层逻辑与契约

### 5.1 计划 JSON（A → B）
```json
{
  "op": "Project", "cols": ["id","name"],
  "child": {"op": "Filter", "pred": "age > 18",
    "child": {"op": "SeqScan", "table": "student"}}
}
```
- **必须支持的 op**：`CreateTable / Insert / SeqScan / Filter / Project / Delete`；
- **错误结构**：`{ etype: "SyntaxError"|"SemanticError", line, col, hint }`。

### 5.2 StorageEngine（B 对上接口）
```py
create_table(name: str, columns: list[dict]) -> None
insert_row(table: str, row: dict) -> None
seq_scan(table: str) -> Iterator[dict]
delete_where(table: str, pred: Callable[[dict], bool]) -> int
```

### 5.3 索引接口（B 内部与上层对接）
```py
create_index(table: str, col: str, kind: str = "ordered") -> None
index_scan(table: str, col: str, op: str, key) -> Iterator[dict]  # op: = < <= > >=
```

### 5.4 触发器 / 存储过程 / 游标（最小子集）
- **触发器**：`AFTER|BEFORE × INSERT|DELETE`；写路径调用 `trigger_mgr.fire(table, action, row)`；
- **存储过程**：`CREATE PROCEDURE p(a INT) BEGIN INSERT...; DELETE...; END;`（顺序执行 + `${a}` 替换）；
- **游标**：`PREPARE(sql) -> cursor_id`，`FETCH(id, n) -> rows, eof`。

---

## 6. 线协议（3306 风格）与客户端
- **端口**：`127.0.0.1:3306`
- **帧**：`len(4B LE) + type(1B) + payload(JSON utf-8)`
- **type**：
  - `0x01 AUTH`, `0x02 QUERY`, `0x03 PREPARE`, `0x04 FETCH`,
  - `0x10 OK`, `0x11 ERR`, `0x12 RESULT`
- **交互**：
  - `AUTH{ user, password } -> OK/ERR`
  - `QUERY{ sql } -> RESULT{ columns, rows } | OK | ERR`
  - `PREPARE{ sql } -> OK{ cursor_id }`
  - `FETCH{ id, size } -> RESULT{ rows, eof }`
- **Python 驱动**：`connect()/execute()/fetchall()/fetchmany(n)`；
- **WinUI3**：`TcpClient` 直连帧协议；时间紧可走“**Python 驱动做本地 HTTP 网桥 → WinUI3 调 HTTP**”。

---

## 7. 7 天里程碑计划（每天都有“可截图”的产物）

| 天 | A：前端 + CLI | B：存储 + 引擎 | C：网络 + 客户端 |
|---|---|---|---|
| **D1** | Lexer ✅ 四元式；CLI `--show=token` | `page.py`/`file_manager.py` 骨架；Buffer 计数器 | 协议草案 + TCP Echo；CLI 连接 |
| **D2** | Parser ✅ AST + “期望符号”错误；`--show=ast` | Buffer LRU/FIFO + 读写页；Catalog 原型 | `QUERY` 路径 → Python 驱动连通 |
| **D3** | Semantic ✅ 表/列/类型/列数；`--show=sem` | StorageEngine 建表/插入/顺扫；持久化验证 | WinUI3 原型（连接/SQL/表格）或 HTTP 网桥 |
| **D4** | Planner ✅ 计划树；`--show=plan` | Executor 跑通五算子；Delete（可选） | `PREPARE/FETCH` 游标分页；CLI/WinUI3 下一页 |
| **D5** | 负样例回放脚本（截图） | **索引 v1：有序块**（等值/范围）；与 SeqScan 对比 | WinUI3 导出 CSV；错误码对齐 |
| **D6** | 可选：ORDER/GROUP/聚合（轻量） | 可选：触发器/存储过程最小子集 | 压测脚本（10 并发）；演示录屏脚本 |
| **D7** | 报告与 PPT：四视图/错误样例/接口图 | 缓存命中/替换日志/索引范围查截图 | 全链路演示（CLI + WinUI3） |

> **强制物料清单**：四视图截图、页/缓存统计、替换日志、持久化重启截图、索引对比图、3306 连通录屏、WinUI3 表格页、负样例集合。

---

## 8. 质量与测试（含“负样例集”）
- **单元**：
  - `test_sql.py`：Token/AST/语义/计划正确性与错误定位；
  - `test_storage.py`：插入/读取/删除、LRU 命中与淘汰；
  - `test_engine.py`：Create/Insert/Select/Delete；索引扫与 SeqScan 对比；
- **集成**：
  - 端到端：CLI → server → planner → executor → storage；
  - 游标分页 PREPARE/FETCH；
- **持久化**：
  - 写入 → 重启 → 再查；核对行计数与校验和；
- **性能微基准**：
  - 1e4/1e5 行插入与查询等值/范围；命中率曲线；
- **负样例集**（自动回放）：
  - 缺分号、未闭合字符串、列名拼写、列数不匹配、类型不匹配、非法字符。

---

## 9. 风险与降级策略
- **索引**：优先“有序块”；B+ 树写为“可替换实现”，接口相同；
- **触发器/过程**：只做最小子集；如卡壳，留 CLI 显示触发日志与过程执行序列；
- **WinUI3**：若 UI 进度落后，提交可运行原型 + 短录屏；CLI 为主展示；
- **页紧凑/分裂**：本期可延期；不影响评分“页式 + 缓存 + 持久化 + 统计”核心；
- **时间预案**：D5 未达索引 → 保留 v1，报告中标注“兼容升级到 B+ 树”。

---

## 10. 立即可做（Start Today）
1) **克隆骨架**：按 §3 目录建仓；
2) **起闭环**：把最小 `executor + storage_engine + planner` 连起来，`CREATE/INSERT/SELECT` 跑通；
3) **四视图**：CLI `--show=token|ast|sem|plan` 出首批截图；
4) **网络**：跑 `server.py`，用 Python 驱动执行 `QUERY`；
5) **物料池**：建立 `docs/daily/`，每日沉淀截图与日志。

---

## 11. “卷项目”建议（按性价比）
- **可视化缓存监控**：命中率曲线、淘汰事件表格；
- **Explain 计划**：把 Plan JSON 渲染为树形（S 表达式），配合“谓词下推”前后对比；
- **索引选择对比**：SeqScan vs IndexScan 的耗时与行数柱状图；
- **最小规则优化**：谓词下推（Filter 提前）与投影下推（只读必要列）；
- **WinUI3“查询模板”**：常用 SQL 片段与导出 CSV/JSON 按钮。

---

## 12. 附录：关键接口与伪代码骨架

### 12.1 Planner（接口稳定）
```py
class Planner:
    def plan(self, sql_text: str) -> dict:
        """SQL → 计划(JSON)。错则 raise SqlError(etype,line,col,hint)。"""
        ...
```

### 12.2 SlottedPage（核心方法）
```py
PAGE_SIZE = 4096
class SlottedPage:
    def __init__(self, page_id: int, raw: bytes | None = None): ...
    def insert(self, rec: bytes) -> int:  # -> slot_id 或 -1 表示页满
        ...
    def read(self, slot_id: int) -> bytes: ...
    def delete(self, slot_id: int) -> None: ...
    def to_bytes(self) -> bytes: ...
    @staticmethod
    def from_bytes(page_id: int, data: bytes) -> "SlottedPage": ...
```

### 12.3 BufferPool（统计/替换日志）
```py
class BufferPool:
    def __init__(self, fm, capacity_pages=64, policy="LRU"): ...
    def get_page(self, pid: int) -> SlottedPage: ...
    def write_page(self, pid: int, page: SlottedPage) -> None: ...
    def stats(self) -> dict:  # {hits, misses, hit_ratio, evictions, policy}
        ...
```

### 12.4 StorageEngine / Executor
```py
class StorageEngine:
    def create_table(self, name: str, columns: list[dict]) -> None: ...
    def insert_row(self, table: str, row: dict) -> None: ...
    def seq_scan(self, table: str) -> "Iterator[dict]": ...
    def delete_where(self, table: str, pred) -> int: ...

class Executor:
    def run(self, plan: dict): ...  # 支持 Create/Insert/SeqScan/Filter/Project/Delete
    def cursor(self, plan: dict): ...  # 返回带 fetchmany(n) 的对象
```

### 12.5 协议常量
```py
TP_AUTH, TP_QUERY, TP_PREP, TP_FETCH = 0x01, 0x02, 0x03, 0x04
TP_OK, TP_ERR, TP_RES = 0x10, 0x11, 0x12
```

---

## 13. 结语
本方案（G 版）以 **“接口稳定 + 渐进替换”** 为核心原则，**D1 起就能演示**，并且把评分项一一绑定到每日物料（截图/日志/录屏）。在 7 天节奏中，保障“必做项”可交付，同时为 **索引 / 过程 / 触发器 / 游标** 等高级项留出 **可控的上升空间**。这既能确保项目“稳”，又能在展示环节“卷”出彩。

